//
//  SingleFileDownloader.swift
//  PCL.Mac
//
//  Created by YiZhiMCQiu on 2025/8/24.
//  Generated by Copilot GPT-5.
//

import Foundation

public class SingleFileDownloader {
    public static func download(
        task: InstallTask? = nil,
        url: URL,
        destination: URL,
        replaceMethod: ReplaceMethod = .skip,
        cacheStorage: CacheStorage? = nil,
        progress: ((Double) -> Void)? = nil
    ) async throws {
        // 若文件已存在，且指定了在存在时跳过，或者缓存中有该文件，直接返回
        if FileManager.default.fileExists(atPath: destination.path) && replaceMethod == .skip
            || cacheStorage?.copyFile(url: url, to: destination) == true {
            task?.completeOneFile()
            progress?(1)
            return
        }
        
        // 创建请求并设置 User-Agent
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("PCL.Mac/\(SharedConstants.shared.version)", forHTTPHeaderField: "User-Agent")
        
        // 发送请求
        let (byteStream, response) = try await URLSession.shared.bytes(for: request)
        
        // 判断响应码是否正确
        if let http = response as? HTTPURLResponse,
           !(200..<300).contains(http.statusCode) {
            err("无法下载 \(destination.lastPathComponent): \(url.host()!) 返回了 \(http.statusCode)")
            throw MyLocalizedError(reason: "远程服务器返回了 \(http.statusCode)。")
        }
        
        // 创建临时文件
        let tempURL = SharedConstants.shared.temperatureURL.appendingPathComponent(UUID().uuidString)
        FileManager.default.createFile(atPath: tempURL.path, contents: nil)
        
        let handle = try FileHandle(forWritingTo: tempURL)
        
        let expectedLength = response.expectedContentLength
        var received: Int64 = 0
        
        var buffer = [UInt8]()
        buffer.reserveCapacity(64 * 1024)
        
        var lastProgressReportTime = CFAbsoluteTimeGetCurrent()
        
        if expectedLength > 0 {
            progress?(0.0)
        } else {
            progress?(-1)
        }
        
        // 从流读取每个字节
        for try await byte in byteStream {
            buffer.append(byte)
            received &+= 1
            
            // 若缓冲区已满，写入到文件并清空
            if buffer.count >= 64 * 1024 {
                await SpeedMeter.shared.addBytes(64 * 1024)
                try Task.checkCancellation()
                handle.write(Data(buffer))
                buffer.removeAll(keepingCapacity: true)
            }
            
            // 调用 progress 回调
            if expectedLength > 0 {
                let now = CFAbsoluteTimeGetCurrent()
                if now - lastProgressReportTime >= 0.1 {
                    let downloadProgress = Double(received) / Double(expectedLength)
                    await MainActor.run {
                        task?.currentStageProgress = downloadProgress
                        progress?(downloadProgress)
                    }
                    lastProgressReportTime = now
                }
            }
        }
        
        // 如果缓冲区还有数据，全部写入到文件
        if !buffer.isEmpty {
            handle.write(Data(buffer))
            buffer.removeAll(keepingCapacity: false)
        }
        
        // 移动临时文件到目标位置
        if FileManager.default.fileExists(atPath: destination.path) {
            if replaceMethod == .replace {
                try FileManager.default.removeItem(at: destination)
            } else if replaceMethod == .throw {
                throw MyLocalizedError(reason: "\(destination.lastPathComponent) 已存在。")
            }
        } else {
            try? FileManager.default.createDirectory(at: destination.parent(), withIntermediateDirectories: true)
        }
        
        try FileManager.default.moveItem(at: tempURL, to: destination)
        if let cacheStorage, let response = response as? HTTPURLResponse,
           let eTag = response.value(forHTTPHeaderField: "ETag"), let lastModified = response.value(forHTTPHeaderField: "Last-Modified") {
            cacheStorage.addFile(from: url, localURL: destination, eTag: eTag, lastModified: lastModified)
        }
        
        task?.completeOneFile()
        progress?(1.0)
    }
}
